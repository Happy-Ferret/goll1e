package main

import (
	"io/ioutil"
	"fmt"
	"os"
	"container/vector"
	"utf8"
)

var dev bool

var s scanner
var terms map[string]int
var nonterms map[string]int
var prods vector.Vector
var firsts map[int]*set
var follows map[int]*set
var table [][]int
var memorizeTerms bool

var packageName string
var imports vector.StringVector

func init() {
	firsts = make(map[int]*set)
	follows = make(map[int]*set)
	terms = make(map[string]int)
	nonterms = make(map[string]int)
	terms[""] = 0
}

type production struct {
	name string	
	seq vector.Vector
	code string
}

func (self *production) String() (output string) {
	output = self.name + "["
	for i, w := range self.seq {
		word := w.(tok)
		if i > 0 {output += " "}
		output += word.text
	}
	output += "]"
	output += self.code
	return
}

func main() {
	filename := "stdin"
	in, out := os.Stdin, os.Stdout
	var err os.Error
	defer func() {
		if in != os.Stdin {in.Close()}
		if out != os.Stdout {out.Close()}
	}()

	if len(os.Args) > 1 {
		filename = os.Args[1]
		in, err = os.Open(filename, os.O_RDONLY, 0)
		if nil != err {
			fmt.Println("Cannot", err)
			os.Exit(-1)
		}
	}
	if len(os.Args) > 2 {
		flags := os.O_CREATE | os.O_WRONLY | os.O_TRUNC
		out, err = os.Open(os.Args[2], flags, 0666)
		if nil != err {
			fmt.Println("Cannot create output file", os.Args[2], ":", err)
			os.Exit(-1)
		}
	}
	
	content, err := ioutil.ReadAll(in)
	if nil != err {
		fmt.Println("Cannot", err)
		os.Exit(-2)
	}

	s.content = content
	parseHeader()
	parseProductions()

	if len(terms) == 1 {
		terms[""] = 0, false
	}

	computeFirsts()
	computeFollows()
	computeTable()

	if dev {
		printTermMap(terms)
		printTermMap(nonterms)
		printProductions()

		printSet(firsts, func(i int) string {return prods[i].(*production).name})
		printSet(follows, func(i int) string {return translateNonterm(i)})

		printTable()
		printTableRaw()		
	}
	
	printFile(out)
}

func printFile(out *os.File) {
	out.WriteString("// Autogenerated by goll1e, a LL(1) parser generator for the Go programming language.\n")
	out.WriteString("package ")
	out.WriteString(packageName)
	out.WriteString("\n\n")
	out.WriteString("import (\n")
	for _, port := range imports {
		out.WriteString("\t\"")
		out.WriteString(port)
		out.WriteString("\"\n")
	}
	out.WriteString(")\n")

	out.WriteString("var parseTable = [")
	out.WriteString(fmt.Sprint(len(table)))
	out.WriteString("][")
	out.WriteString(fmt.Sprint(len(table[0])))
	out.WriteString("]int {\n")
	for r := 0; r < len(table); r++ {
		out.WriteString("\t[")
		out.WriteString(fmt.Sprint(len(table[0])))
		out.WriteString("]int{")
		for c := 0; c < len(table[0]); c++ {
			out.WriteString(fmt.Sprint(table[r][c]))
			out.WriteString(",")
		}
		out.WriteString("},\n")
	}
	out.WriteString("}\n")
	
	maxChar := 0
	out.WriteString("var charMap = map[int]int {\n")
	for token, i := range terms {
		if i == 0 || token[0] != '\'' {continue}
		char, _ := utf8.DecodeRuneInString(token[1:])
		if char > maxChar {maxChar = char}
		out.WriteString("\t")
		out.WriteString(token)
		out.WriteString(":")
		out.WriteString(fmt.Sprint(i))
		out.WriteString(",\n")
	}
	out.WriteString("}\n")
	
	maxChar++
	maxToken := maxChar + len(terms) + 1
	out.WriteString("const (\n")
	out.WriteString("\tMAXCHAR = ")
	out.WriteString(fmt.Sprint(maxChar))
	out.WriteString("\n")
	for token, i := range terms {
		if i == 0 || token[0] == '\'' {continue}
		out.WriteString("\t")
		out.WriteString(token)
		out.WriteString(" = ")
		out.WriteString(fmt.Sprint(i + maxChar))
		out.WriteString("\n")
	}
	out.WriteString("\tMAXTOKEN = ")
	out.WriteString(fmt.Sprint(maxToken))
	out.WriteString("\n")
	out.WriteString(")\n")
	
	out.WriteString("var parseProductions = [")
	out.WriteString(fmt.Sprint(len(prods)))
	out.WriteString("][]int {\n")
	for _, p := range prods {
		prod := p.(*production)
		out.WriteString("\t[")
//		out.WriteString(fmt.Sprint(len(prod.seq)))
		out.WriteString("]int{")
		for _, t := range prod.seq {
			token := t.(tok)
			switch token.ttype {
			case term:
				out.WriteString(fmt.Sprint(terms[token.text] + maxChar))
			case nonterm:
				out.WriteString(fmt.Sprint(nonterms[token.text] + maxToken))
			}
			out.WriteString(",")
		}
		out.WriteString("},\n")
	}
	out.WriteString("}\n")
	
	out.WriteString("func translateToken(t int) int {\n\tif t < MAXCHAR {return charMap[t]}\n\treturn t - MAXCHAR\n}\n")
	
	out.WriteString("\n")
}
