package main

import (
	"io/ioutil"
	"fmt"
	"os"
	"container/vector"
)

var dev bool = true

var s scanner
var terms map[string]int
var nonterms map[string]int
var prods vector.Vector
var firsts map[int]*set
var follows map[int]*set
var table [][]int
var memorizeTerms bool

var packageName string
var imports vector.StringVector

func init() {
	firsts = make(map[int]*set)
	follows = make(map[int]*set)
	terms = make(map[string]int)
	nonterms = make(map[string]int)
	terms[""] = 0
}

type production struct {
	name string	
	seq vector.Vector
	code string
}

func (self *production) String() (output string) {
	output = self.name + "["
	for i, w := range self.seq {
		word := w.(tok)
		if i > 0 {output += " "}
		output += word.text
	}
	output += "]"
	output += self.code
	return
}

func main() {
	filename := "stdin"
	in, out := os.Stdin, os.Stdout
	var err os.Error
	defer func() {
		if in != os.Stdin {in.Close()}
		if out != os.Stdout {out.Close()}
	}()

	if len(os.Args) > 1 {
		filename = os.Args[1]
		in, err = os.Open(filename, os.O_RDONLY, 0)
		if nil != err {
			fmt.Println("Cannot", err)
			os.Exit(-1)
		}
	}
	if len(os.Args) > 2 {
		flags := os.O_CREATE | os.O_WRONLY | os.O_TRUNC
		out, err = os.Open(os.Args[2], flags, 0666)
		if nil != err {
			fmt.Println("Cannot create output file", os.Args[2], ":", err)
			os.Exit(-1)
		}
	}
	
	content, err := ioutil.ReadAll(in)
	if nil != err {
		fmt.Println("Cannot", err)
		os.Exit(-2)
	}

	s.content = content
	parseHeader()
	parseProductions()

	if len(terms) == 1 {
		terms[""] = 0, false
	}

	computeFirsts()
	computeFollows()
	computeTable()

	if dev {
		printTermMap(terms)
		printTermMap(nonterms)
		printProductions()

		printSet(firsts, func(i int) string {return prods[i].(*production).name})
		printSet(follows, func(i int) string {return translateNonterm(i)})

		printTable()
		printTableRaw()		
	}
	
	printFile(out)
}

func printFile(out *os.File) {
	out.WriteString("// Autogenerated by goll1e, a LL(1) parser generator for the Go programming language.\n")
	out.WriteString("package ")
	out.WriteString(packageName)
	out.WriteString("\n\n")
	out.WriteString("import (\n")
	for _, port := range imports {
		out.WriteString("\t\"")
		out.WriteString(port)
		out.WriteString("\"\n")
	}
	out.WriteString(")\n")
	
	for _, p := range prods {
		prod := p.(*production)
		if len(prod.code) > 0 {
			out.WriteString(prod.code)
			out.WriteString("\n")			
		}
	}
	
	out.WriteString("\n")
}
