package main

import (
	"io/ioutil"
	"fmt"
	"os"
	"container/vector"
	"utf8"
)

var dev bool

var s scanner
var terms map[string]int
var nonterms map[string]int
var prods vector.Vector
var firsts map[int]*set
var follows map[int]*set
var table [][]int
var memorizeTerms bool

var packageName string
var imports vector.StringVector

func init() {
	firsts = make(map[int]*set)
	follows = make(map[int]*set)
	terms = make(map[string]int)
	nonterms = make(map[string]int)
	terms[""] = 0
}

type production struct {
	name string	
	seq vector.Vector
	code string
}

func (self *production) String() (output string) {
	output = self.name + "["
	for i, w := range self.seq {
		word := w.(tok)
		if i > 0 {output += " "}
		output += word.text
	}
	output += "]"
	output += self.code
	return
}

func main() {
	filename := "stdin"
	in, out := os.Stdin, os.Stdout
	var err os.Error
	defer func() {
		if in != os.Stdin {in.Close()}
		if out != os.Stdout {out.Close()}
	}()

	if len(os.Args) > 1 {
		filename = os.Args[1]
		in, err = os.Open(filename, os.O_RDONLY, 0)
		if nil != err {
			fmt.Println("Cannot", err)
			os.Exit(-1)
		}
	}
	if len(os.Args) > 2 {
		flags := os.O_CREATE | os.O_WRONLY | os.O_TRUNC
		out, err = os.Open(os.Args[2], flags, 0666)
		if nil != err {
			fmt.Println("Cannot create output file", os.Args[2], ":", err)
			os.Exit(-1)
		}
	}
	
	content, err := ioutil.ReadAll(in)
	if nil != err {
		fmt.Println("Cannot", err)
		os.Exit(-2)
	}

	s.content = content
	parseHeader()
	parseProductions()

	if len(terms) == 1 {
		terms[""] = 0, false
	}

	computeFirsts()
	computeFollows()
	computeTable()

	if dev {
		printTermMap(terms)
		printTermMap(nonterms)
		printProductions()

		printSet(firsts, func(i int) string {return prods[i].(*production).name})
		printSet(follows, func(i int) string {return translateNonterm(i)})

		printTable()
		printTableRaw()		
	}
	
	printFile(out)
	out.Write(s.remainder())
}

func printFile(out *os.File) {
	out.WriteString("// Autogenerated by goll1e, a LL(1) parser generator for the Go programming language.\n")
	out.WriteString("package ")
	out.WriteString(packageName)
	out.WriteString("\n\n")
	out.WriteString("import (\n")
	out.WriteString("\t\"container/vector\"\n")
	for _, port := range imports {
		if port == "container/vector" {continue}
		out.WriteString("\t\"")
		out.WriteString(port)
		out.WriteString("\"\n")
	}
	out.WriteString(")\n\n")

	out.WriteString("var parseTable = [")
	out.WriteString(fmt.Sprint(len(table)))
	out.WriteString("][")
	out.WriteString(fmt.Sprint(len(table[0])))
	out.WriteString("]int {\n")
	for r := 0; r < len(table); r++ {
		out.WriteString("\t[")
		out.WriteString(fmt.Sprint(len(table[0])))
		out.WriteString("]int{")
		for c := 0; c < len(table[0]); c++ {
			out.WriteString(fmt.Sprint(table[r][c]))
			out.WriteString(",")
		}
		out.WriteString("},\n")
	}
	out.WriteString("}\n")
	
	maxChar := 0
	out.WriteString("var charMap = map[int]int {\n")
	for token, i := range terms {
		if i == 0 || token[0] != '\'' {continue}
		char, _ := utf8.DecodeRuneInString(token[1:])
		if char > maxChar {maxChar = char}
		out.WriteString("\t")
		out.WriteString(token)
		out.WriteString(":")
		out.WriteString(fmt.Sprint(i))
		out.WriteString(",\n")
	}
	out.WriteString("}\n")
	
	maxChar++
	maxToken := maxChar + len(terms) + 1
	out.WriteString("const (\n")
	out.WriteString("\tMINTOKEN int = ")
	out.WriteString(fmt.Sprint(maxChar))
	out.WriteString("\n")
	for token, i := range terms {
		if i == 0 || token[0] == '\'' {continue}
		out.WriteString("\t")
		out.WriteString(token)
		out.WriteString(" = ")
		out.WriteString(fmt.Sprint(i + maxChar))
		out.WriteString("\n")
	}
	out.WriteString("\tMAXTOKEN = ")
	out.WriteString(fmt.Sprint(maxToken))
	out.WriteString("\n")
	out.WriteString("\tUSER = ")
	out.WriteString(fmt.Sprint(maxToken + len(prods) + 1))
	out.WriteString("\n")
	out.WriteString(")\n")
	
	out.WriteString("var parseProductions = [")
	out.WriteString(fmt.Sprint(len(prods)))
	out.WriteString("][]int {\n")
	for _, p := range prods {
		prod := p.(*production)
		out.WriteString("\t[")
		out.WriteString("]int{")
		for _, t := range prod.seq {
			token := t.(tok)
			switch token.ttype {
			case term:
				if token.text[0] == '\'' {
					r, _ := utf8.DecodeRuneInString(token.text[1:])
					out.WriteString(fmt.Sprint(r))
				} else {
					out.WriteString(fmt.Sprint(terms[token.text] + maxChar))
				}
			case nonterm:
				out.WriteString(fmt.Sprint(nonterms[token.text] + maxToken + 1))
			}
			out.WriteString(",")
		}
		out.WriteString("},\n")
	}
	out.WriteString("}\n")
	
	out.WriteString("func translateToken(t int) int {\n" +
					"	if t >= MAXTOKEN {return t - MAXTOKEN - 1}\n" +
					"	if t <= MINTOKEN {return charMap[t]}\n" +
					"	return t - MINTOKEN\n" +
					"}\n" +
					"func parse(eof int, nextWord func()int) bool {\n" +
					"	word := nextWord()\n" +
					"	var stack vector.IntVector\n" +
					"	stack.Push(eof)\n" +
					"	stack.Push(" + fmt.Sprint(maxToken + 1) + ")\n" +
					"	tos := stack.Last()\n" +
					"	for true {\n" +
					"		if tos == eof && word == eof {return true}\n" +
					"		if (tos < MAXTOKEN) || tos == eof {\n" +
					"			if tos == word {\n" +
					"				stack.Pop()\n" +
					"				word = nextWord()\n" +
					"				tos = stack.Last()\n" +
					"			} else {break}\n" +
					"		} else {\n" +
					"			row, col := translateToken(tos), translateToken(word)\n" +
					"			if parseTable[row][col] == -1 {break}\n" +
					"			stack.Pop()\n" +
					"			ruleNumber := parseTable[row][col]\n" +
					"			for i := len(parseProductions[ruleNumber]) - 1;\n" +
					"				i >= 0;\n" +
					"				i-- {\n" +
					"				stack.Push(parseProductions[ruleNumber][i])\n" +
					"			}\n" +
					"			tos = stack.Last()\n" +
					"		}\n" +
					"	}\n" +
					"	return false\n" +
					"}\n")
	
	out.WriteString("\n")
}
